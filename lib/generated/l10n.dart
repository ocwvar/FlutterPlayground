// GENERATED CODE - DO NOT MODIFY BY HAND
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'intl/messages_all.dart';

// **************************************************************************
// Generator: Flutter Intl IDE plugin
// Made by Localizely
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, lines_longer_than_80_chars
// ignore_for_file: join_return_with_assignment, prefer_final_in_for_each
// ignore_for_file: avoid_redundant_argument_values, avoid_escaping_inner_quotes

class S {
  S();

  static S? _current;

  static S get current {
    assert(_current != null,
        'No instance of S was loaded. Try to initialize the S delegate before accessing S.current.');
    return _current!;
  }

  static const AppLocalizationDelegate delegate = AppLocalizationDelegate();

  static Future<S> load(Locale locale) {
    final name = (locale.countryCode?.isEmpty ?? false)
        ? locale.languageCode
        : locale.toString();
    final localeName = Intl.canonicalizedLocale(name);
    return initializeMessages(localeName).then((_) {
      Intl.defaultLocale = localeName;
      final instance = S();
      S._current = instance;

      return instance;
    });
  }

  static S of(BuildContext context) {
    final instance = S.maybeOf(context);
    assert(instance != null,
        'No instance of S present in the widget tree. Did you add S.delegate in localizationsDelegates?');
    return instance!;
  }

  static S? maybeOf(BuildContext context) {
    return Localizations.of<S>(context, S);
  }

  /// `What's the weather today ?`
  String get whatsTheWeather {
    return Intl.message(
      'What\'s the weather today ?',
      name: 'whatsTheWeather',
      desc: '',
      args: [],
    );
  }

  /// `This text only have English version`
  String get missingOtherTranslate {
    return Intl.message(
      'This text only have English version',
      name: 'missingOtherTranslate',
      desc: '',
      args: [],
    );
  }

  /// `This is place holder 1 "{ph1}", and this is place holder 2 "{ph2}"`
  String placeHolderTesting(Object ph1, Object ph2) {
    return Intl.message(
      'This is place holder 1 "$ph1", and this is place holder 2 "$ph2"',
      name: 'placeHolderTesting',
      desc: '',
      args: [ph1, ph2],
    );
  }

  /// `The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.`
  String get longText {
    return Intl.message(
      'The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.The only value for blendMode that is supported on all platforms is BlendMode.srcOver which works well for most scenes. But that value may produce surprising results when a parent of the BackdropFilter uses a temporary buffer, or save layer, as does an Opacity widget. In that situation, a value of BlendMode.src can produce more pleasing results, but at the cost of incompatibility with some platforms, most notably the html renderer for web applications.',
      name: 'longText',
      desc: '',
      args: [],
    );
  }
}

class AppLocalizationDelegate extends LocalizationsDelegate<S> {
  const AppLocalizationDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale.fromSubtags(languageCode: 'en'),
      Locale.fromSubtags(languageCode: 'zh'),
      Locale.fromSubtags(languageCode: 'zh'),
    ];
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale);
  @override
  Future<S> load(Locale locale) => S.load(locale);
  @override
  bool shouldReload(AppLocalizationDelegate old) => false;

  bool _isSupported(Locale locale) {
    for (var supportedLocale in supportedLocales) {
      if (supportedLocale.languageCode == locale.languageCode) {
        return true;
      }
    }
    return false;
  }
}
